//! ФУНКЦІЇ

//TODO Оголошення функції
// Оголошення функції(function declaration) починається з ключового слова function,
// після якого стоїть ім'я - дієслово, що відповідає на запитання «Що зробити?» і пара круглих дужок.

// Тіло функції береться у фігурні дужки { } і містить інструкції,
// які необхідно виконати на момент її виклику.
// Потім, коли необхідно, функція викликається за допомогою імені і пари круглих дужок.

// 1. Оголошення функції multiply
// function multiply() {
  // Тіло функції
//   console.log("Це лог на момент виклику функції multiply");
// }

// 2. Виклики функції multiply
// multiply(); // 'Це лог на момент виклику функції multiply'
// multiply(); // 'Це лог на момент виклику функції multiply'
// multiply(); // 'Це лог на момент виклику функції multiply'

//TODO Параметри та аргументи
//В круглих дужках після імені функції зазначаються параметри -
// перелік даних, які функція очікує на момент виклику.

// Оголошення параметрів x, y, z
// function multiply(x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// }
// На момент виклику функції, в круглих дужках можна передати аргументи -
// значення для оголошених параметрів функції.

// 2. Передача аргументів
// multiply(2, 3, 5); // Результат множення дорівнює 30
// multiply(4, 8, 12); // Результат множення дорівнює 384
// multiply(17, 6, 25); // Результат множення дорівнює 2550

//TODO Повернення значення
// Оператор return використовується для передачі значення з тіла функції у зовнішній код.
// Коли інтерпретатор зустрічає return, він відразу ж виходить з функції(припиняє її виконання),
// і повертає вказане значення у те місце коду, де була викликана функція.
// function multiply(x, y, z) {
//     console.log("Код до return виконується звичайним чином");

//Повертаємо результат виразу множення
//         return message = `Результат множення ${x} * ${y} * ${z} = ${x *y *z}`;
    

//   console.log("Цей лог ніколи не виконається, він стоїть після return");
// }

//Результат роботи функції можна зберегти у змінну
// let message;
// multiply(2, 3, 5); // 30
// console.log(message);

// multiply(4, 8, 12); // 384
// console.log(message);

// multiply(17, 6, 25); // 2550
// console.log(message);

//TODO Порядок виконання коду
// function multiply(x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// }

// console.log("Лог до виклику функції multiply");
// multiply(2, 3, 5); // Результат множення дорівнює 30
// console.log("Лог після виклику функції multiply");

// Послідовність логів в консолі
// "Лог до виклику функції multiply"
// "Результат множення дорівнює 30"
// "Лог після виклику функції multiply"

//TODO Параметри за замовчуванням
// Іноді необхідно оголосити функцію, у параметрів якої будуть значення, відмінні від undefined,
// навіть якщо для них не передали аргументи.Це робиться дуже простим та очевидним чином -
// достатньо вказати значення за замовчуванням безпосередньо на момент оголошення параметрів у підписі функції.
// У випадку такого запису, якщо для параметра не було передано значення аргументу, використовується значення за замовчуванням.

// function count(countFrom = 0, countTo = 10, step = 1) {
//   console.log(`countFrom = ${countFrom}, countTo = ${countTo}, step = ${step}`);

//   for (let i = countFrom; i <= countTo; i += step) {
//     console.log(i);
//   }
// }

// count(1, 5); // countFrom = 1, countTo = 5, step = 1
// count(2); // countFrom = 2, countTo = 10, step = 1
// count(); // countFrom = 0, countTo = 10, step = 1

//TODO Псевдомасив arguments
// Доступ до списку всіх аргументів можна отримати за допомогою спеціальної змінної arguments,
// яка доступна тільки всередині функції і зберігає всі аргументи у якості псевдомасиву.

// Псевдомасив - колекція з властивістю length і можливістю звернутися до елементу за індексом,
// але відсутністю більшості методів для роботи з масивом.

// ПРИКЛАД. Розглянемо приклад використання arguments у функції, яка множить будь-яку кількість аргументів:
// function multiply() {
//   let total = 1;

//   for (const argument of arguments) {
//     total *= argument;
//   }

//   return total;
// }

// console.log(multiply(1, 2, 3)); //  6
// console.log(multiply(1, 2, 3, 4)); //  24
// console.log(multiply(1, 2, 3, 4, 5)); //  120

//TODO Перетворення псевдомасиву
// Зазвичай псевдомасив необхідно перетворити у повноцінний масив, оскільки у псевдомасиву відсутні методи масиву,
// наприклад slice() або includes().На практиці застосовують декілька основних способів.

//Варіант № 1 //? Array.from(), створить масив із псевдомасиву.
// function fn() {
// Змінна args буде містити повноцінний масив
//   const args = Array.from(arguments);
// }

//Варіант № 2 Використовуючи операцію ... (rest) //? дозволяє зібрати будь-яку кількість елементів, у нашому випадку аргументів,
// //? в масив, і зберегти його в змінну. Збираємо всі аргументи, використовуючи операцію rest безпосередньо в підписі функції.

// function fn(...args) {
// Змінна args буде містити повноцінний масив
// }

//TODO Патерн «Раннє повернення»
// ПРИКЛАД. Створимо функцію, яка обробляє зняття коштів з особистого рахунку в банку.
// Вона отримує суму для зняття і поточний баланс рахунку, після чого, залежно від умови, виконує необхідний блок коду.
// function withdraw(amount, balance) {
//   if (amount === 0) {
//     console.log("Для проведення операції введіть суму більшу за нуль");
//   } else if (amount > balance) {
//     console.log("Недостатньо коштів на рахунку");
//   } else {
//     console.log("Операція зняття коштів проведена успішно");
//   }
// }

// withdraw(0, 300); // "Для проведення операції введіть суму більшу за нуль"
// withdraw(500, 300); // "Недостатньо коштів на рахунку"
// withdraw(100, 300); // "Операція зняття коштів проведена успішно"

//? Патерн «Раннє повернення» - це спосіб використовувати можливість дострокового повернення з функції за допомогою оператора return.
//? Використовуючи цей прийом, ми отримуємо чистіший, плоскіший і зрозуміліший код, який простіше рефакторити.

//Виділимо всі перевірки умов в окремі оператори if, після чого додамо код, що знаходиться в тілі else.
// В ідеальному випадку, повинен вийти плоский список умовних операторів, що йдуть один за одним,
//а в кінці - блок, який виконається тільки у тому випадку, якщо не виконається жоден if.

// function withdraw(amount, balance) {
// Якщо умова виконується, викликається console.log
/// і вихід із функції. Код після тіла if не виконається.
//   if (amount === 0) {
//     console.log("Для проведення операції введіть суму більшу за нуль");
//     return;
//   }

// Якщо умова першого if не виконалась, його тіло пропускається
// та інтерпретатор доходе до другого if.
// Якщо умова виконується, викликається console.log і вихід із функції.
// Код, що знаходиться після тіла if, не виконається.
//   if (amount > balance) {
//     console.log("Недостатньо коштів на рахунку");
//     return;
//   }

// Якщо жоден із попередніх if не виконався,
// інтерпретатор доходить до цього коду і виконує його.
//   console.log("Операція зняття коштів проведена");
// }

// withdraw(0, 300); // "Для проведення операції введіть суму більшу за нуль"
// withdraw(500, 300); // "Недостатньо коштів на рахунку"
// withdraw(100, 300); // "Операція зняття коштів проведена"

//TODO Функціональний вираз
//? Функціональний вираз(function expression) - звичайне оголошення змінної, значенням якої буде функція.
//? Альтернативний спосіб оголошення функції.

// Оголошення функції (function declaration)
// function multiply(x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// }

// Функціональний вираз (function expression)
// const multiply = function (x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// };

// Різниця в тому, що функціональний вираз не можна викликати до місця його створення,
// тільки після нього, тому що це буквально оголошення const змінної.

// ❌ Помилка! Не працює виклик до оголошення
// multiply(1, 2, 3);

// const multiply = function (x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// };

// ✅ Працює виклик після оголошення
// multiply(4, 5, 6);

// A оголошення функції можна викликати до місця її створення в коді.
// ✅ Працює виклик до оголошення
// multiply(1, 2, 3);

// function multiply(x, y, z) {
//   console.log(`Результат множення дорівнює ${x * y * z}`);
// }

// ✅ Працює виклик після оголошення
// multiply(4, 5, 6);

//! ОБЛАСТЬ ВИДИМОСТІ
//? Область видимості (scope) - механізм, який визначає доступність змінних у коді, що виконується.
// Ланцюжок областей видимості(scope chain) - області видимості утворюють ієрархію,
// за якою дочірні області мають доступ до змінних з батьківських областей, але не навпаки.

//TODO Глобальна область видимості
// Змінні, оголошені на найвищому рівні, тобто за межами будь - яких конструкцій на зразок if, while, for і функцій,
// знаходяться в глобальній області видимості і доступні всюди після їх оголошення
// const globalValue = 10;

// console.log(globalValue); // 10

// function foo() {
//   console.log(globalValue); // 10
// }

// for (let i = 0; i < 5; i++) {
//   console.log(globalValue); // 10

//   if (i === 2) {
//     console.log(globalValue); // 10
//   }
// }

//TODO Блокова область видимості
// Змінні, оголошені всередині інструкцій if, for, функцій та інших блоків коду, взятих у фігурні дужки { },
// знаходяться в блоковій області видимості і доступні тільки всередині цього блоку коду або у блоках, вкладених в нього.
// function foo() {
//   const a = 20;
//   console.log(`function a=${a}`); // 20

//   for (let i = 0; i < 5; i++) {
//     console.log(`for ${i} a=${a}`); // 20

//     if (i === 2) {
//       console.log(`if ${i} a=${a}`); // 20
//     }
//   }
// }
// foo();

// ❌ Помилка! Змінна a - недоступна у глобальній області видимості
// console.log(a);

// for (let i = 0; i < 3; i++) {
// ❌ Помилка! Змінна a - недоступна в цій області видимості
//   console.log(a);
// }

// Приклад №1
// for (let i = 0; i < 5; i++) {
//   const a = 20;
//   console.log(`for ${i} a=${a}`); // 20

//   if (i === 2) {
//     const b = 30;
//     console.log(`if ${i} a=${a}`); // 20
//     console.log(`if ${i} b=${b}`); // 30
//   }

//   if (i === 3) {
//     console.log(`if3 ${i} a=${a}`); // 20

// ❌ Помилка! Змінна b - недоступна в цій області видимості
//     console.log(b);
//   }
// }

//! СТЕК ВИКЛИКІВ
// На момент виклику функції, всередині її тіла можуть викликатися інші функції, а в них - інші тощо.
// JavaScript - однопотокова мова, тобто за одну одиницю часу може виконуватись лише одна інструкція.
// Це означає, що викликані функції, які не завершили своє виконання, повинні чекати виконання функцій,
// викликаних всередині них, для того, щоб продовжити свою роботу.
// function fnA() {
//   console.log("Лог всередині функції fnA до виклику fnB");
//   fnB();
//   console.log("Лог всередині функції fnA після виклику fnB");
// }

// function fnB() {
//   console.log("Лог всередині функції fnB");
// }

// console.log("Лог до виклику fnA");
// fnA();
// console.log("Лог після виклику fnA");

// "Лог до виклику fnA"
// "Лог всередині функції fnA до виклику fnB"
// "Лог всередині функції fnB"
// "Лог всередині функції fnA після виклику fnB"
// "Лог після виклику fnA"

//TODO Потрібен механізм зберігання списку функцій, які були викликані, але ще не завершили своє виконання,
//TODO і механізм керування порядком виконання цих функцій - саме за це відповідає стек викликів(call stack).
// Стек викликів(call stack) - це механізм для відстеження поточного місцезнаходження інтерпретатора в коді,
// який викликає декілька функцій.Яка із функцій виконується на цей момент, які функції викликаються всередині функції,
// що виконується, яка функція буде викликана наступною тощо.

// Коли скрипт викликає функцію, інтерпретатор додає її в стек викликів і починає виконання.
// Будь-які функції, викликані функцією, що виконується, додаються у стек викликів і виконуються, щойно відбувається їх виклик.
// Коли виконання функції завершено, інтерпретатор знімає її зі стека викликів і відновлює виконання коду з тієї точки,
// де зупинився до цього.Тобто починає виконуватися функція, запис якої наступний у стеку.

// Stack frame(кадр стека, запис стека) - структура, яка додається у стек на момент виклику функції.
// Зберігає службову інформацію, наприклад, ім'я функції і номер рядка, в якому був виклик.
// function bar() {
//   console.log("bar");
// }

// function baz() {
//   console.log("baz");
// }

// function foo() {
//   console.log("foo");
//   bar();
//   baz();
// }

// foo();